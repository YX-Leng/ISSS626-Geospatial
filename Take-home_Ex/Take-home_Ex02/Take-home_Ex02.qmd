---
title: "Take-home Exercise 2: Discovering impacts of COVID-19 on Thailand tourism economy at the province level using spatial and spatio-temporal statistics"
author: "Leng Yi Xiu"
date: "Oct 14 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  message: false
  freeze: true
---

# 1 Overview

Tourism is a major industry in Thailand, contributing around 20% to the country's gross domestic product (GDP). In 2019, Thailand generated 90 billion US dollars from both domestic and international tourism. However, due to the COVID-19 pandemic, this revenue sharply declined to 24 billion US dollars in 2020.

It's also important to recognize that Thailand's tourism economy is not evenly distributed across the country. The tourism economy of Thailand is mainly focused on five provinces, namely Bangkok, Phuket, Chiang Mai, Sukhothai and Phetchaburi.

## 1.1 Objective

The objective of this exercise is to explore whether key indicators of Thailand's tourism economy are independent of spatial and spatio-temporal factors. If dependencies exist, we want to identify clusters, outliers, and emerging hot or cold spots. The exercise involves the following tasks:

-   Create a geospatial data layer of Thailand's provinces (including Bangkok) as an *`sf`* polygon layer.

-   Develop a tourism economy indicators layer for the study area, also in *`sf`* polygon features.

-   Derive a tourism economy indicator layer in a spatio-temporal format (*`spacetime s3 class`*) using *`sfdep`*, maintaining a monthly and yearly time series.

-   Perform **global spatial autocorrelation analysis** using *`sfdep`* to determine overall spatial dependence.

-   Conduct **local spatial autocorrelation analysis** to detect specific clusters and outliers.

-   Carry out an **emerging hotspot analysis** to identify trends in hot or cold spots over time

-   Describe the spatial patterns revealed by the analysis above.

------------------------------------------------------------------------

# 2 Getting Started

The code chunk below installs and loads **sf, sfdep, ggstatsplot, tmap, tidyverse, spdep, patchwork, Kendall** packages into R environment

```{r}
pacman::p_load(sf, sfdep, ggstatsplot, tmap, tidyverse, spdep, patchwork, Kendall)
```

------------------------------------------------------------------------

# 3 Data Preparation

For the purpose of this exercise, we will be using two data sets:

-   Thailand Domestic Tourism Statistics (**thaitour**)\
    The dataset contains statistics on domestic tourism in Thailand, by province, from Jan 2019 to Feb 2023. Information includes the number of tourists, the occupancy rate, the profits generated by tourism as well as the nationality of the tourists (Thai vs. foreign).

-   Thailand Subnational Adminstrative Boundaries (**province**)\
    The dataset contains Thailand's administrative level 0 (country), 1 (province), 2 (district), and 3 (sub-district, tambon) boundaries.

## 3.1 Importing data into R Environment

::: panel-tabset
## Tourism Statistics

```{r}
thaitour <- read_csv ("data/rawdata/thailand_domestic_tourism_2019_2023_ver2.csv")
```

```{r}
list(thaitour)
```

ðŸ’¡To check the different attributes in the data set

```{r}
thaitour %>%
  count(variable) %>%
  print()
```

ðŸ’¡To check the different provinces in the data set

```{r}
thaitour %>%
  count(province_eng) %>%
  print()
```

## Administrative Boundaries

```{r}
province <- st_read(dsn = "data/rawdata", layer = "tha_admbnda_adm1_rtsd_20220121")
```

```{r}
st_crs(province) <- 4326
province <- st_transform(province, crs = 32647)
head(province,5)
```
:::

## 3.2 Data Wrangling

### *3.2.1 Check for duplicates & drop unwanted columns*

To ensure no duplicate rows are presented and only the English columns are selected, the following code chunk is used:

```{r}
thaitour <- thaitour %>% 
  distinct() %>% 
        select(date,province_eng,region_eng,variable,value)
```

### *3.2.2 Perform Relational Join*

Perform a left join of both data sets and select only columns that will be used in analysis:

```{r}
thai <- left_join(thaitour,province,
                  by = c("province_eng" = "ADM1_EN"), relationship = "many-to-many") %>%
  select(1:7,21)
```

### *3.2.3 Filter for missing / mismatched values*

```{r}
filter_thai <- thai %>%
  filter(is.na(Shape_Area))

filter_thai %>%
  distinct(province_eng) %>%
  print()
```

::: callout-important
## Findings

The above code chunk filters for rows with empty Shape_Area and Geometry - this is indicative that there are mismatches between the 2 data sets and the province name are not compatible between the Tourism Statistics and Administrative Boundaries.

The 8 provinces have been misspelled in the Tourism Statistics data set and will need to be corrected before the data sets can be merged correctly.
:::

### *3.2.4 Correct province names in Tourism Statistics*

```{r}
thaitour_v2 <- thaitour %>%
  mutate(province_eng = case_when(
    province_eng == "Lopburi" ~ "Lop Buri",
    province_eng == "Chainat" ~ "Chai Nat",
    province_eng == "Chonburi" ~ "Chon Buri",
    province_eng == "Prachinburi" ~ "Prachin Buri",
    province_eng == "Phang Nga" ~ "Phangnga",
    province_eng == "Buriram" ~ "Buri Ram",
    province_eng == "Sisaket" ~ "Si Sa Ket",
    province_eng == "Nong Bua Lamphu" ~ "Nong Bua Lam Phu",
    TRUE ~ province_eng  # Keep all other values unchanged
  ))
```

### *3.2.5 Perform Relational Join & check that there are no more mismatched provinces*

```{r}
thai_v2 <- left_join(thaitour_v2,province,
                  by = c("province_eng" = "ADM1_EN"), relationship = "many-to-many") %>%
  select(1:7,21)
```

```{r}
any(is.na(thai_v2))
```

### *3.2.6 Check for values less than zero (errors)*

```{r}
value_neg <- thai_v2 %>%
  filter(value < 0)

value_neg
```

::: callout-important
## Findings

The above code chunk filters out 2 records of foreign revenue where the value is negative. For purpose of analysis in this exercise, these 2 records will be corrected to zero as revenue should not be negative.

Final data set will remain with 30,800 observations.
:::

```{r}
thai_v2 <- thai_v2 %>%
  mutate(value = pmax(value, 0))
```

### *3.2.7 Split out the 8 attributes to unique columns*

```{r}
thai_final <- thai_v2 %>%
  pivot_wider(names_from = variable, values_from = value)
```

### *3.2.8 Split out the date column to Year and Month*

```{r}
thai_final <- thai_final %>%
  mutate(
    year = year(date.x),
    month = month(date.x)
  )
```

### *3.2.9*

### *3.2.10 Save transformed data in rds folder*

```{r}
thai_final <- st_as_sf(thai_final, crs = 32647)
thai_final
```

```{r}
write_rds(thai_final, "data/rds/thai_final.rds")
```

------------------------------------------------------------------------

# 4 Exploratory Data Analysis (EDA)

In order to study the impact and changes of the Covid-19 pandemic on Thailand's tourism industry and the changes pre-covid and post-covid, we will be focusing on 2 time periods for the EDA, namely:

-   Pre-Covid : Year 2019

-   Post-Covid : Year 2022

The comparison is to show the changes in tourism trends post-covid and highlight any concerns in terms of accommodation occupancy rates as well as foreign travelers to Thailand. To highlight that for ease of analysis, EDA will be focused on the five key provinces, namely Bangkok, Phuket, Chiang Mai, Sukhothai and Phetchaburi.

## 4.1 Filter data set by year

```{r}
thai_2019 <- thai_final %>%
  filter(year %in% c("2019")) %>%
   group_by(province_eng) %>% 
  summarise(across(c(ratio_tourist_stay/12, no_tourist_stay, no_tourist_all, no_tourist_thai, 
                     no_tourist_foreign, revenue_all, revenue_thai, revenue_foreign), 
                   ~sum(.x, na.rm = TRUE))) 

```

```{r}
thai_2022 <- thai_final %>%
  filter(year %in% c("2022")) %>%
   group_by(province_eng) %>% 
  summarise(across(c(ratio_tourist_stay/12, no_tourist_stay, no_tourist_all, no_tourist_thai, 
                     no_tourist_foreign, revenue_all, revenue_thai, revenue_foreign), 
                   ~sum(.x, na.rm = TRUE))) 
```

## 4.2 Plot total revenue by Province

```{r}
tmap_mode("plot")
tm_shape(thai_2019) +
  tm_fill("revenue_all", 
          style = "quantile", 
          palette = "Blues",
          title = "Total Revenue") +
  tm_layout(main.title = "Distribution of total revenue by Province",
            main.title.position = "center",
            main.title.size = 1.2,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2) + 
    tm_text("province_eng", 
           size = 0.35,    
           col = "black", 
           remove.overlap = TRUE) 
tmap_mode("plot")
```

## 4.3 Comparison between local and foreign revenue

```{r}
# Combine both data sets into a single data frame
thai_combined <- thai_2019 %>%
  mutate(year = "2019") %>%
  select(province_eng, revenue_thai, revenue_foreign, year) %>%
  bind_rows(thai_2022 %>% mutate(year = "2022") %>% select(province_eng, revenue_thai, revenue_foreign, year)) %>%
  filter(province_eng %in% c("Bangkok", "Phuket", "Chiang Mai", "Sukhothai", "Phetchaburi"))

# Create a facet plot
ggplot(thai_combined, aes(x = reorder(province_eng, (revenue_thai + revenue_foreign)), y = (revenue_thai + revenue_foreign))) +
  geom_bar(stat = "identity", position = "stack", fill = "pink") +
  geom_bar(stat = "identity", position = "stack", aes(y = revenue_foreign), fill = "blue") +
  labs(title = "Comparison of Total Revenue by Province (2019 vs 2022)", x = "Province", y = "Revenue") +
  theme_minimal() +
  coord_flip() +
  facet_wrap(~ year)
```

## 4.4 Comparison between local and foreign tourists (count)

```{r}
# Combine both data sets into a single data frame
thai_combined <- thai_2019 %>%
  mutate(year = "2019") %>%
  select(province_eng, no_tourist_thai, no_tourist_foreign, year) %>%
  bind_rows(thai_2022 %>% mutate(year = "2022") %>% select(province_eng, no_tourist_thai, no_tourist_foreign, year)) %>%
  filter(province_eng %in% c("Bangkok", "Phuket", "Chiang Mai", "Sukhothai", "Phetchaburi"))

# Create a facet plot
ggplot(thai_combined, aes(x = reorder(province_eng, (no_tourist_thai + no_tourist_foreign)), y = (no_tourist_thai + no_tourist_foreign))) +
  geom_bar(stat = "identity", position = "stack", fill = "pink") +
  geom_bar(stat = "identity", position = "stack", aes(y = no_tourist_foreign), fill = "blue") +
  labs(title = "Comparison of Number of Tourists by Province (2019 vs 2022)", x = "Province", y = "Number of Tourists") +
  theme_minimal() +
  coord_flip() +
  facet_wrap(~ year)
```

------------------------------------------------------------------------

# 5 Global Spatial Autocorrelation Analysis

::: callout-important
## Assumption

As geographic boundaries are assumed to remain the same over the years, spatial analysis will use data from **Year 2019 only** for ease of analysis.
:::

## 5.1 Spatial Weights Matrix

The spatial weights matrix defines the degree of interaction or influence that one geographic unit has on another based on their spatial relationships. There are two commonly used methods of spatial weights: **contiguity-based** and **distanced-based**.

### *5.1.1 Contiguity-based*

Contiguity weights define relationships based on whether geographic units share a boundary. For example, in a grid or map, two areas are considered contiguous if they touch each other. For **contiguity-based** matrix, it can be further broken down into 2 methods:

::: panel-tabset
## Queen Contiguity

Neighbors need to only share a common vertex **or** edge, which is more encompassing than Rook.

```{r}
thai_q <- poly2nb(thai_2019, 
                queen=TRUE)
summary(thai_q)
```

## Rook Contiguity

Neighbors need to share a common edge.

```{r}
thai_r <- poly2nb(thai_2019, 
                queen=FALSE)
summary(thai_r)
```

## Summary

Both Queen and Rook continuity return similar results:

1.  On average, each province is connected to approximately 4.57 other provinces

2.  There is 1 province (region 48) that has no links, meaning it is isolated and probably an island

3.  2 disjoint connected subgraphs suggest that the spatial regions can be divided into 2 distinct groups where the provinces are connected within each group, but there are no connections between the 2 groups. This indicates a fragmented spatial layout.

Since the provinces are sparsely connected, we will look into a distance-based approach to see if it can provide a more nuanced view of the spatial relationships.
:::

### *5.1.2 Distance-based*

On the other hand, distance-based weights identifies neighbors of region points by Euclidean distance with a distance band with lower and upper bounds.

For **distance-based** matrix, it can be further broken down into fixed or adaptive weight matrix. In order to calculate the distance-based matrix, we will first need to associate each polygon with a point and its coordinates can be derived using the *`st_centroid()`* function.

```{r}
# calculate the centroid
centroid2019 <- st_centroid(thai_2019)

coords <- st_coordinates(centroid2019)
```

::: panel-tabset
## Fixed

Finding the largest first nearest neighbour distance

```{r}
k1 <- knn2nb(knearneigh(coords, k = 1))
k1dists <- unlist(nbdists(k1, coords))
summary(k1dists)
```

```{r}
thai_2019$province_eng[match(max(k1dists), k1dists)]
```

Computing the fixed distance weight matrix

```{r}
fixedwm <- dnearneigh(coords,0,110000)
fixedwm 
```

```{r}
par(mfrow = c(1,2))
plot(thai_2019$geometry, border = "lightgrey",main="1st nearest neighbours" )
plot(k1, coords, add = TRUE, col = "red", length = 0.88, )

plot(thai_2019$geometry, border = "lightgrey", main = "Distance Link")
plot(fixedwm, coords, add = TRUE, pch = 19, cex = 0.6)
```

From the observations of the fixed-distance weight matrix, average number of links remain at approximately 4.5 other provinces. However, provinces have been separated into 3 separate groups and this can be noticed from the charts above where neighbour links are dense in the central area only (Bangkok).

With this uneven distribution of neighbours, we should directly control the numbers of neighbours using k-nearest neighbours in the adaptive-based method.

## Adaptive

We will set k = 5 based on the average number of links being approximately 4.5 to 5.

```{r}
adaptwm <- knn2nb(knearneigh(coords, k=5))
adaptwm
```

```{r}
par(mfrow = c(1,2))
plot(thai_2019$geometry, border = "lightgrey",main="5 nearest neighbours" )
plot(adaptwm, coords, add = TRUE, col = "red", length = 0.88, )

plot(thai_2019$geometry, border = "lightgrey", main = "Distance Link w KNN")
plot(adaptwm, coords, add = TRUE, pch = 19, cex = 0.6)
```
:::

### *5.1.3 Selecting a spatial weight matrix*

Selecting a spatial weight matrix is use is dependent on the geographical area of interest and the focus of the study.

Between contiguity-based and distance-based spatial weight matrices, we lean towards distance-based matrices as:

1.  Based on observations from contiguity-based matrices, provinces are sparsely connected in Thailand.

Within distance-based matrices, we will select adaptive distance-based spatial weight matrix as it allows weights to vary based on local characteristics.

### *5.1.4 Row-Standardised Weights Matrix*

```{r}
rswm <- nb2listw(adaptwm,
                   style = "W",
                   zero.policy = TRUE)
rswm
```

::: {.callout-note appearance="simple"}
We will use 2 methods, **Moranâ€™s I** and **Gearyâ€™s C** to test the following hypothesis:

-   H0: Observed spatial patterns of values is equally likely as any other spatial pattern i.e. data is randomly disbursed, no spatial pattern

-   H1: Data is more spatially clustered than expected by chance alone
:::

### *5.1.5 Moranâ€™s I*

::: callout-note
## 5.1.5.1 Revenue

For both foreign and local Thai revenue, p-value is \> 0.05 hence we are ***unable to reject the null hypothesis***. Data is randomly disbursed and no significant spatial pattern is observed.

To further test for the assumptions of Moran I, we can use a Monte Carlo simulation to perform a permutation test for Moranâ€™s I. Results from the 1000 simulations performed also show that p-value is \> 0.05 and null hypothesis cannot be rejected.
:::

-   Test for foreign revenue:

```{r}
moran.test(thai_2019$revenue_foreign,
           listw = rswm,
           zero.policy = TRUE,
           na.action = na.omit)
```

-   Monte Carlo simulation for foreign revenue:

```{r}
set.seed(1234)
bperm_rev_foreign = moran.mc(thai_2019$revenue_foreign, 
         listw = rswm,
         nsim = 999,
         zero.policy = TRUE,
         na.action = na.omit)
bperm_rev_foreign
```

-   Test for local revenue:

```{r}
moran.test(thai_2019$revenue_thai,
           listw = rswm,
           zero.policy = TRUE,
           na.action = na.omit)
```

-   Monte Carlo simulation for local revenue:

```{r}
set.seed(1234)
bperm_rev_local = moran.mc(thai_2019$revenue_thai, 
         listw = rswm,
         nsim = 999,
         zero.policy = TRUE,
         na.action = na.omit)
bperm_rev_local
```

### *5.1.6 Gearyâ€™s C*

::: callout-note
#### 5.1.6.1 Revenue

Using Geary's C, the results for both foreign and local Thai revenue is similar, p-value is \> 0.05 hence we are ***unable to reject the null hypothesis***. Data is randomly disbursed and no significant spatial pattern is observed.
:::

-   Test for foreign revenue:

```{r}
geary.test(thai_2019$revenue_foreign, listw = rswm)
```

-   Monte Carlo simulation for foreign revenue:

```{r}
set.seed(1234)
gearyforeign = geary.mc(thai_2019$revenue_foreign,
                 listw = rswm,
                 nsim = 999)
gearyforeign
```

-   Test for local revenue:

```{r}
geary.test(thai_2019$revenue_thai, listw = rswm)
```

-   Monte Carlo simulation for local revenue:

```{r}
set.seed(1234)
gearylocal = geary.mc(thai_2019$revenue_thai,
                 listw = rswm,
                 nsim = 999)
gearylocal
```

::: callout-important
## Conclusion - Global Spatial Autocorrelation

Overall, there is no spatial dependence and economic data is randomly disbursed for the study period of 2019.
:::

------------------------------------------------------------------------

# 6 Local spatial autocorrelation analysis

Local Moran's I is a statistical measure used in spatial data analysis to detect clusters of similar or dissimilar values across geographic locations.

Positive Local Moran's I value will mean the existence of spatial clusters, or an area is surrounded by areas with similar values. On contrary, negative Local Moran's I value will indicate a spacial outlier.

-   Test for foreign revenue:

```{r}
lm_foreign <- localmoran(thai_2019$revenue_foreign, rswm)
head(lm_foreign)
```

```{r}
thai_2019.lm_foreign <- cbind(thai_2019,lm_foreign) %>%
  rename(Pr.Ii = Pr.z....E.Ii..)
```

```{r}
lm_foreign.map <- tm_shape(thai_2019.lm_foreign) +
  tm_fill(col = "Ii", 
          style = "pretty",
          title = "Local Moran I Statistics") +
  tm_borders(alpha = 0.3) + 
  tm_layout(main.title = "Local Moran's I Map \n(Foreign Revenue)",
            main.title.size = 1,
            main.title.position = "center",
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE)

pvalue_foreign.map <- tm_shape(thai_2019.lm_foreign) + 
                tm_fill(col = "Pr.Ii",
                       breaks = c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),
                       palette = "-Blues",
                       title = "Local Moran's I p-values") + 
                tm_borders(alpha = 0.3)+ 
  tm_layout(main.title = "Local Moran's I p-values Map \n(Foreign Revenue)",
            main.title.size = 1,
            main.title.position = "center",
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE)

tmap_arrange(lm_foreign.map, pvalue_foreign.map, asp = 1, ncol = 2)
```

-   Test for local revenue:

```{r}
lm_local <- localmoran(thai_2019$revenue_thai, rswm)
head(lm_local)
```

```{r}
thai_2019.lm_local <- cbind(thai_2019,lm_local) %>%
  rename(Pr.Ii = Pr.z....E.Ii..)
```

```{r}
lm_local.map <- tm_shape(thai_2019.lm_local) +
  tm_fill(col = "Ii", 
          style = "pretty",
          title = "Local Moran I Statistics") +
  tm_borders(alpha = 0.3) + 
  tm_layout(main.title = "Local Moran's I Map \n(Thai Revenue)",
            main.title.size = 1,
            main.title.position = "center",
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE)

pvalue_local.map <- tm_shape(thai_2019.lm_local) + 
                tm_fill(col = "Pr.Ii",
                       breaks = c(-Inf, 0.001, 0.01, 0.05, 0.1, Inf),
                       palette = "-Blues",
                       title = "Local Moran's I p-values") + 
                tm_borders(alpha = 0.3)+ 
  tm_layout(main.title = "Local Moran's I p-values Map \n(Thai Revenue)",
            main.title.size = 1,
            main.title.position = "center",
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE)

tmap_arrange(lm_local.map, pvalue_local.map, asp = 1, ncol = 2)
```

::: callout-important
## Conclusion - Local Spatial Autocorrelation

For both foreign and local revenue, the spatial cluster can be specifically noticed in the Central region around Bangkok.

Interesting to note that the province of Chonburi also shows positive Local Moran I values. This could be indicative of the some spatial dependence to Bangkok as tourists would also Pattaya (in Chonburi) when on holidays.
:::

# 7 Emerging hotspot analysis

## 7.1 Creating a Time Series Cube

```{r}
#thai_st <- as_spacetime(thai_final,
                        #.loc_col = "province_eng",  
                        #.time_col = "date.x")
```

```{r}
#is_spacetime_cube(thai_st)
```

## 7.1 Computing Gi\*

### *7.1.1 Deriving the spatial weights*

```{r}
#thai_nb <- thai_st %>%
  #activate("geometry") %>%
  #mutate(nb = include_self(
    #st_contiguity(geometry)),
    #wt = st_inverse_distance(nb, 
                             #geometry, 
                             #scale = 1,
                             #alpha = 1),
    #.before = 1) %>%
  #set_nbs("nb") %>%
  #set_wts("wt")
```

### *7.1.2 Local Gi\**

```{r}
#gi_stars <- thai_nb %>% 
  #group_by(Year) %>% 
  #mutate(gi_star = local_gstar_perm(
    #GDPPC, nb, wt)) %>% 
  #tidyr::unnest(gi_star)
```

## 7.2 Emerging Hotspot Analysis

```{r}
#ehsa <- emerging_hotspot_analysis(
  #x = thai_st, 
  #.var = "revenue_all", 
  #k = 1, 
  #nsim = 99
#)
```

```{r}
#ggplot(data = ehsa,
       #aes(x = classification)) +
  #geom_bar()
```

