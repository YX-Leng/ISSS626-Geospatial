---
title: "Hands-on Exercise 2"
author: "Leng Yi Xiu"
date: "Aug 31 2024"
date-modified: "last-modified"
execute: 
  eval: true
  echo: true
  message: false
  freeze: true
---

## **Getting Started**

In this hands-on exercise, we will be exploring **Spatial Point Pattern Analysis** and learning to use the R Packages:

-   **spatstat** for 1st- and 2nd-order spatial point patterns analysis and kernel density estimation (KDE) layer,

-   **raster** for converting image output generated by spatstat into raster format, and

-   **maptools** for converting *`Spatial`* objects into *`ppp`* format of spatstat.

::: {.callout-tip appearance="simple"}
**Spatial Point Pattern Analysis** is the evaluation of the pattern or distribution, of a set of points on a surface. The point can be location of:

-   events such as crime, traffic accident and disease onset, or

-   business services (coffee and fastfood outlets) or facilities such as childcare and eldercare.
:::

```{r}
pacman::p_load(sf, raster, spatstat, tmap, tidyverse)
```

## **Spatial Data Wrangling**

### Importing the spatial data

ðŸ’¡Import 3 geospatial data sets into R

```{r}
childcare_sf <- st_read("D:/2. SMU - MITB/Term 4/ISSS626 Geospatial/YX-Leng/ISSS626-Geospatial/Hands-on_Ex/Hands-on_Ex02/data/child-care-services-geojson.geojson") %>%
  st_transform(crs = 3414)
```

```{r}
sg_sf <- st_read(dsn = "D:/2. SMU - MITB/Term 4/ISSS626 Geospatial/YX-Leng/ISSS626-Geospatial/Hands-on_Ex/Hands-on_Ex02/data", layer="CostalOutline")
```

```{r}
sg_sf3414 <- st_set_crs(sg_sf, 3414)
st_crs(sg_sf3414)
```

```{r}
mpsz_sf <- st_read(dsn = "D:/2. SMU - MITB/Term 4/ISSS626 Geospatial/YX-Leng/ISSS626-Geospatial/Hands-on_Ex/Hands-on_Ex02/data", 
                layer = "MP14_SUBZONE_WEB_PL")
```

```{r}
mpsz_sf3414 <- st_set_crs(mpsz_sf, 3414)
st_crs(mpsz_sf3414)
```

### Mapping the geospatial data sets

ðŸ’¡Using ggplot:

```{r}
ggplot() +
  geom_sf(data = mpsz_sf3414, fill = "gray90", color = "gray50") +           # Plot polygons
  geom_sf(data = childcare_sf, color = "black", size = 0.5) +                # Plot points
  labs(title = "Spatial Distribution of Childcare Centres over Singapore") + # Add title
  theme_minimal() +
  theme( 
    axis.title = element_blank(),             # Remove axis titles
    axis.text = element_blank(),              # Remove axis text
    axis.ticks = element_blank(),             # Remove axis ticks
    axis.line = element_blank(),              # Remove axis lines
    plot.title = element_text(hjust = 0.5)    #centre the title
  )

```

ðŸ’¡Using tmap (pin map):

```{r}
tmap_mode('view')
tm_shape(childcare_sf)+
  tm_dots()
```

```{r}
tmap_mode('plot')
```

## Geospatial Data Wrangling

### Converting sf data frames to sp's Spatial class

```{r}
childcare <- as_Spatial(childcare_sf)
mpsz <- as_Spatial(mpsz_sf3414)
sg <- as_Spatial(sg_sf3414)
```

```{r}
childcare
```

```{r}
mpsz
```

```{r}
sg
```

### Converting the Spatial class into generic sp format

**Spatstat** requires the analytical data to be in *`ppp`* object form, but in order to convert a Spatial class into *`ppp`* form, we need to first convert the Spatial classes into Spatial object first.

ðŸ’¡Converting the Spatial classes into generic sp objects

```{r}
childcare_sp <- as(childcare, "SpatialPoints")
sg_sp <- as(sg, "SpatialPolygons")
```

ðŸ’¡Display the sp oject properties

```{r}
childcare_sp
```

```{r}
sg_sp
```

### Converting the generic sp format into spatstat's ppp format

ðŸ’¡Use the *`as.ppp()`* function to convert spatial data into *`ppp`* object format

```{r}
childcare_ppp <- as.ppp(childcare_sf)
childcare_ppp
```

::: {.callout-caution appearance="simple"}
Warning indicates that the 'childcare_sf' object likely has multiple attribute columns and for purpose of marking the points in the point pattern, it will only use the first attribute column and ignore the rest.

We can specify the correct column or combine attributes column as needed.
:::

```{r}
plot(childcare_ppp)
```

```{r}
summary(childcare_ppp)
```

### Handling duplicated points

```{r}
any(duplicated(childcare_ppp))
```

```{r}
sum(multiplicity(childcare_ppp) > 1)
```

```{r}
tmap_mode('view')
tm_shape(childcare) +
  tm_dots(alpha=0.4, 
          size=0.05)
```

```{r}
tmap_mode('plot')
```

::: {.callout-note appearance="simple"}
**How to spot the duplicate points from the map shown above?**

1.  Delete the duplicates, but this will also mean that some useful point events will be lost.
2.  Use *jittering,* which will add a small perturbation to the duplicate points so that they do not occupy the same space.
3.  Make each point "unique" and then attach the duplicates of the points to the patterns as marks (attributes of the points).
:::

ðŸ’¡The jittering approach

```{r}
childcare_ppp_jit <- rjitter(childcare_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

```{r}
any(duplicated(childcare_ppp_jit))
```

### Creating *`owin`* object

```{r}
sg_owin <- as.owin(sg_sf)
plot(sg_owin)
```

```{r}
summary(sg_owin)
```

### Combining point events object and owin object

```{r}
childcareSG_ppp = childcare_ppp[sg_owin]
plot(childcareSG_ppp)
```

```{r}
summary(childcareSG_ppp)
```

## First-order Spatial Point Patterns Analysis

In this section, we learn how to perform first-order SPPA by using **spatstat** package, focusing on:

-   deriving **kernel density estimation (KDE)** layer for visualising and eploring the intensity of point processes, and

-   performing **Confirmatory Spatial Point Patterns Analysis** by using **Nearest Neighbour** statistics.

### Kernel Density Estimation (KDE)

#### Computing KDE using automatic bandwidth selection method

```{r}
kde_childcareSG_bw <- density(childcareSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian") 

plot(kde_childcareSG_bw)
```

::: {.callout-tip appearance="simple"}
-   *`bw.diggle()`*: automatic bandwidth selection method

-   Smoothing kernel used is gaussian, which is default. Other smoothing methods are "epanechnikov", "quartic" or "disc".

-   The intensity estimate is corrected for edge effect bias
:::

::: {.callout-caution appearance="simple"}
The density values of the output range **from 0 to 0.000035** which is way too small to comprehend. This is because default unit of measurement of svy21 is in **meter** \>\> "number of points per square meter".
:::

```{r}
bw <- bw.diggle(childcareSG_ppp)
bw
```

#### Rescaling KDE values (to km instead of meter)

```{r}
childcareSG_ppp.km <- rescale.ppp(childcareSG_ppp, 1000, "km")
```

```{r}
kde_childcareSG.bw <- density(childcareSG_ppp.km, sigma=bw.diggle, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG.bw)
```

### Working with different automatic bandwidth methods

```{r}
 bw.CvL(childcareSG_ppp.km)
```

```{r}
bw.scott(childcareSG_ppp.km)
```

```{r}
bw.ppl(childcareSG_ppp.km)
```

```{r}
bw.diggle(childcareSG_ppp.km)
```

ðŸ’¡Code chunk used to compare the outputs of 2 different automatic bandwidth methods

```{r}
kde_childcareSG.ppl <- density(childcareSG_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")
```

### Working with different kernel methods

```{r}
par(mfrow=c(2,2))
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"), 
     main="Disc")
```

## Fixed and Adaptive KDE

### Computing KDE by using fixed bandwidth

```{r}
kde_childcareSG_600 <- density(childcareSG_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG_600)
```

::: {.callout-tip appearance="simple"}
Sigma value is 0.6 because unit of measurement of **childcareSG_ppp.km** object is in kilometers. 600m = 0.6km
:::

### Computing KDE by using adaptive bandwidth

```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive)
```

ðŸ’¡Comparing the fixed and adaptive KDE outputs

```{r}
par(mfrow=c(1,2))
plot(kde_childcareSG.bw, main = "Fixed bandwidth")
plot(kde_childcareSG_adaptive, main = "Adaptive bandwidth")
```

### Converting KDE output into grid object

```{r}
gridded_kde_childcareSG_bw <- as.im(kde_childcareSG.bw)
plot(gridded_kde_childcareSG_bw)
```

#### Converting gridded output into raster

```{r}
kde_childcareSG_bw_raster <- raster(kde_childcareSG.bw)
kde_childcareSG_bw_raster
```

#### Assigning projection systems (for crs = NA)

```{r}
projection(kde_childcareSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_childcareSG_bw_raster
```

### Visualising output in tmap

```{r}
tm_shape(kde_childcareSG_bw_raster) + 
  tm_raster("layer", palette = "viridis") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

### Comparing Spatial Point Patterns using KDE

ðŸ’¡Comparing KDE of childcare at Punggol, Tampines, Chua Chu Kang and Jurong West planning areas

#### 1. Extract study area

```{r}
pg <- mpsz_sf %>%
  filter(PLN_AREA_N == "PUNGGOL")
tm <- mpsz_sf %>%
  filter(PLN_AREA_N == "TAMPINES")
ck <- mpsz_sf %>%
  filter(PLN_AREA_N == "CHOA CHU KANG")
jw <- mpsz_sf %>%
  filter(PLN_AREA_N == "JURONG WEST")
```

```{r}
par(mfrow=c(2,2))
plot(pg, main = "Ponggol")
```

```{r}
plot(tm, main = "Tampines")
```

```{r}
plot(ck, main = "Choa Chu Kang")
```

```{r}
plot(jw, main = "Jurong West")
```

#### 2. Creating *`owin`* object

```{r}
pg_owin = as.owin(pg)
tm_owin = as.owin(tm)
ck_owin = as.owin(ck)
jw_owin = as.owin(jw)
```

#### 3. Combining childcare points and the study area

```{r}
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

ðŸ’¡Re-scale to KM

```{r}
childcare_pg_ppp.km = rescale.ppp(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale.ppp(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale.ppp(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale.ppp(childcare_jw_ppp, 1000, "km")
```

```{r}
par(mfrow=c(2,2))
plot(childcare_pg_ppp.km, main="Punggol")
plot(childcare_tm_ppp.km, main="Tampines")
plot(childcare_ck_ppp.km, main="Choa Chu Kang")
plot(childcare_jw_ppp.km, main="Jurong West")
```

#### 4. Computing KDE (bw.diggle method)

```{r}
par(mfrow=c(2,2))
plot(density(childcare_pg_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tempines")
plot(density(childcare_ck_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Choa Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
```

#### 5. Computing fixed bandwidth (250m) KDE

```{r}
par(mfrow=c(2,2))
plot(density(childcare_ck_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Chou Chu Kang")
plot(density(childcare_jw_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JUrong West")
plot(density(childcare_pg_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Punggol")
plot(density(childcare_tm_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Tampines")
```

## Nearest Neighbour Analysis

In this section, we will perform the Clark-Evans test of aggregation for a spatial point pattern by using *`clarkevans.test()`* of **statspat**.

The test hypothesis are:

-   Ho = The distribution of childcare services are randomly distributed.

-   H1= The distribution of childcare services are not randomly distributed.

-   95% confident interval will be used.

### **Testing spatial point patterns using Clark and Evans Test**

```{r}
clarkevans.test(childcareSG_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

::: {.callout-tip appearance="simple"}
## Conclusion drawn from results

p-value is \< 0.05, indicating that observed clustering is highly statistically significant and H0 can be rejected. Childcare centres are clustered in Singapore.
:::

### **Clark and Evans Test: CCK planning area**

```{r}
clarkevans.test(childcare_ck_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

### **Clark and Evans Test: Tampines planning area**

```{r}
clarkevans.test(childcare_tm_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

# Second-order Spatial Point Patterns Analysis

In this section, we will learn how to compute G-function estimation by using *`Gest()`*, *`Fest()`*, *`Kest()`* and *`Lest()`* of **spatstat** package. We will also learn how to perform monta carlo simulation test using *`envelope()`* of **spatstat** package.

## G-Function

::: panel-tabset
## Chua Chu Kang

Computing G-function estimation

```{r}
G_CK = Gest(childcare_ck_ppp, correction = "border")
plot(G_CK, xlim=c(0,500))
```

Performing Complete Spatial Randomness Test

ðŸ’¡To confirm the observed spatial patterns, a hypothesis test will be conducted:

-   H0 = Distribution of childcare services at CCK are randomly distributed

-   H1 = Distribution of childcare services at CCK are **not** randomly distributed

-   99% confident interval will be used (H0 rejected if p-value \< 0.001)

```{r}
G_CK.csr <- envelope(childcare_ck_ppp, Gest, nsim = 999)
```

```{r}
plot(G_CK.csr)
```

## Tampines

Computing G-function estimation

```{r}
G_tm = Gest(childcare_tm_ppp, correction = "best")
plot(G_tm)
```

Performing Complete Spatial Randomness Test

```{r}
G_tm.csr <- envelope(childcare_tm_ppp, Gest, correction = "all", nsim = 999)
```

```{r}
plot(G_tm.csr)
```
:::

## F-Function

::: panel-tabset
## Chua Chu Kang

Computing F-function estimation

```{r}
F_CK = Fest(childcare_ck_ppp)
plot(F_CK)
```

Performing Complete Spatial Randomness Test

```{r}
F_CK.csr <- envelope(childcare_ck_ppp, Fest, nsim = 999)
```

```{r}
plot(F_CK.csr)
```

## Tampines

Computing F-function estimation

```{r}
F_tm = Fest(childcare_tm_ppp, correction = "best")
plot(F_tm)
```

Performing Complete Spatial Randomness Test

```{r}
F_tm.csr <- envelope(childcare_tm_ppp, Fest, correction = "all", nsim = 999)
```

```{r}
plot(F_tm.csr)
```
:::

## K-Function

::: panel-tabset
## Chua Chu Kang

Computing K-function estimation

```{r}
K_ck = Kest(childcare_ck_ppp, correction = "Ripley")
plot(K_ck, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)")
```

Performing Complete Spatial Randomness Test

```{r}
K_ck.csr <- envelope(childcare_ck_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(K_ck.csr, . - r ~ r, xlab="d", ylab="K(d)-r")
```

## Tampines

Computing K-function estimation

```{r}
K_tm = Kest(childcare_tm_ppp, correction = "Ripley")
plot(K_tm, . -r ~ r, ylab= "K(d)-r", xlab = "d(m)",
     xlim=c(0,1000))
```

Performing Complete Spatial Randomness Test

```{r}
K_tm.csr <- envelope(childcare_tm_ppp, Kest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(K_tm.csr, . - r ~ r, 
     xlab="d", ylab="K(d)-r", xlim=c(0,500))
```
:::

## L-Function

::: panel-tabset
## Chua Chu Kang

Computing L-function estimation

```{r}
L_ck = Lest(childcare_ck_ppp, correction = "Ripley")
plot(L_ck, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)")
```

Performing Complete Spatial Randomness Test

```{r}
L_ck.csr <- envelope(childcare_ck_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_ck.csr, . - r ~ r, xlab="d", ylab="L(d)-r")
```

## Tampines

Computing L-function estimation

```{r}
L_tm = Lest(childcare_tm_ppp, correction = "Ripley")
plot(L_tm, . -r ~ r, 
     ylab= "L(d)-r", xlab = "d(m)", 
     xlim=c(0,1000))
```

Performing Complete Spatial Randomness Test

```{r}
L_tm.csr <- envelope(childcare_tm_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_tm.csr, . - r ~ r, 
     xlab="d", ylab="L(d)-r", xlim=c(0,500))
```
:::
